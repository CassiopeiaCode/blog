

# **KTH Omogen Heap 综合技术报告**

本报告旨在对KTH皇家理工学院的“Omogen Heap”技术手册进行详尽的分析与阐述，该手册由Simon Lindholm、Johan Sannemo和Mårten Wiman于2024年11月24日编撰。报告将深入探讨其内容，涵盖从竞赛基础到高级数学、数据结构、数值算法、数论、组合数学、图论、几何以及字符串处理等多个领域，并揭示其在竞技编程实践中的深层意义与应用价值。

## **第一章 竞赛基础**

竞技编程的成功不仅依赖于算法知识，还取决于高效的开发流程和完善的调试策略。本章将探讨KTH手册中为参赛者提供的基础工具和指导原则。

### **1.1 竞赛模板**

KTH手册提供了一个简洁而高效的C++竞赛模板，旨在优化开发速度和程序运行效率 。该模板的核心组成部分包括：

* **通用头文件与命名空间：** \#include \<bits/stdc++.h\> 这一非标准但广泛应用于竞技编程的头文件，能够一次性引入几乎所有标准库，极大地简化了代码编写过程，避免了记忆和逐一引入特定头文件的繁琐。紧随其后的 using namespace std; 进一步减少了代码冗余，使得代码更为紧凑和易读 。这种做法体现了在竞赛环境下，实用性和开发效率往往优先于严格的语言规范。  
* **宏定义：** 模板中定义了常用的宏，例如 rep(i, a, b) 用于简化循环结构，all(x) 用于方便地获取容器的迭代器范围，以及 sz(x) 用于获取容器大小并进行类型转换。值得注意的是，原始模板中存在一些小错误，如 5z(x) 应为 sz(x)，typedef long long 11; 应为 typedef long long ll; 。这些细微的笔误也反映了在快速迭代和优化模板过程中可能出现的疏漏，但其核心目的——提升编码效率和可读性——是明确的。  
* **类型别名：** typedef long long ll;、typedef pair\<int, int\> pii; 和 typedef vector\<int\> vi; 等类型别名，使得常用数据类型声明更加简洁，有助于快速编写代码并保持一致性 。  
* **快速I/O：** cin.tie(0)-\>sync\_with\_stdio(0); cin.exceptions(cin.failbit); 是C++竞技编程中提升输入输出速度的关键优化手段 。通过解除C++流与C标准流的同步，并禁用cin的绑定，可以显著减少I/O操作的开销，避免因输入输出过慢而导致的“时间限制超出”（TLE）问题。cin.exceptions(cin.failbit) 则是一种防御性编程实践，它会在输入失败时立即抛出异常，有助于在早期阶段发现无效输入或格式错误。

这些模板特性共同构成了一种高度优化的工作流，其中每一毫秒的编码时间节省和每一微秒的执行时间优化都对竞赛结果至关重要。它向新的参赛者传达了从一开始就重视这些优化的理念。

### **1.2 故障排除指南**

KTH手册提供了一份详细的故障排除指南，为参赛者在面对常见问题时提供了系统化的解决方案 。这份指南将问题分为提交前检查、错误答案、运行时错误、时间限制超出和内存限制超出五大类，体现了在竞技编程高压环境下系统化调试的重要性。

* **提交前检查：** 强调了在提交代码前进行基本验证的重要性，包括编写简单测试用例、评估时间限制并生成最大测试用例、确认提交文件正确、检查内存使用情况以及是否存在溢出风险 。这些步骤旨在预防最常见的低级错误。  
* **错误答案 (Wrong Answer)：** 针对逻辑错误和不正确输出，指南建议打印调试信息、确保测试用例间数据结构清空、检查算法是否能处理所有输入范围、重新阅读问题描述、处理所有边界情况、确认对问题理解正确、检查未初始化变量、处理溢出、避免混淆变量名、验证算法正确性、考虑特殊情况、添加断言、创建新测试用例、向队友解释算法，甚至进行短暂休息或重写代码 。这份列表不仅涵盖了技术性的调试方法，还包含了认知心理学层面的建议，如通过解释算法来理清思路，或通过短暂休息来获得新的视角。  
* **运行时错误 (Runtime Error)：** 针对程序崩溃或异常终止，指南建议在本地测试所有边界情况、检查未初始化变量、确认是否存在越界读写、验证断言是否可能失败、检查除以零（包括模数为零）的可能性、是否存在无限递归、指针或迭代器是否失效，以及内存使用是否过多 。这些建议旨在帮助参赛者识别和解决导致程序异常终止的底层问题。  
* **时间限制超出 (Time Limit Exceeded)：** 针对程序运行时间过长，指南建议检查是否存在无限循环、评估算法复杂度、避免不必要的数据复制（使用引用）、考虑输入输出规模（推荐使用scanf）、避免使用std::vector和std::map（推荐使用数组和std::unordered\_map），并与队友讨论算法 。这些建议强调了理解算法效率和资源管理的重要性，特别是对于C++标准库容器，其常数因子开销在严格的时间限制下可能成为瓶颈。  
* **内存限制超出 (Memory Limit Exceeded)：** 针对程序占用内存过多，指南建议评估算法所需的最大内存量，并确保在测试用例之间清空所有数据结构 。这强调了内存管理在竞技编程中的关键作用。

这份指南是一份在竞技编程高压环境中进行系统化调试的范本。它通过分类、优先级排序和涵盖技术与心理层面的建议，帮助参赛者高效地诊断和解决问题，培养了结构化的解决问题能力。

### **1.3 环境配置**

KTH手册中详细介绍了用于优化竞技编程开发环境的配置，这些配置旨在提高效率、增强错误检测能力并确保代码一致性 。这些“幕后”的基础设施对于顶级竞技程序员而言至关重要。

* **.bashrc 配置：**  
  * alias c 'g++ \-Wall \-Wconversion \-Wfatal-errors \-g-std=c++17 \-fsanitize undefined, address'：这个别名定义了一个强大的编译命令。其中，-Wall 和 \-Wconversion 启用了所有常见警告和类型转换警告，有助于在编译阶段发现潜在问题；-Wfatal-errors 会将警告升级为错误，强制程序员解决所有警告；-g 包含了调试信息，便于使用调试器；-std=c++17 指定了C++语言标准，确保代码在不同编译环境下的兼容性；而 \-fsanitize undefined, address 则是运行时消毒器，undefined 能够检测未定义行为（如整数溢出、使用未初始化变量），address 则能检测内存错误（如越界访问、重复释放），这些工具能够捕捉到难以诊断的运行时问题，显著降低因语言特性或内存错误导致的“错误答案”或“运行时错误” 。  
  * xmodmap \-e 'clear lock' 'keycode 66=less greater NoSymbol NoSymbol NoSymbol NoSymbol' 和 xmodmap \-e 'keycode 66=Caps\_Lock NoSymbol NoSymbol NoSymbol NoSymbol NoSymbol'：这些 xmodmap 命令用于重新映射键盘按键。例如，将Caps Lock键（keycode 66）映射为 \< 和 \> 符号，或重新映射回Caps Lock功能。这种自定义映射可以根据个人习惯优化键盘布局，提高输入效率 。  
* **.vimrc 配置：**  
  * set cin aw al is ts 4 sw-4 tm-50 nu noeb bg-dark ru cul sy on im jk \<esc\> im kj \<esc\>：这些Vim设置是竞技编程中常见的优化，例如 ts=4 和 sw=4 确保了代码缩进的一致性；nu 显示行号；sy on 开启语法高亮；bg=dark 设置深色背景以提高视觉舒适度。im jk \<esc\> 和 im kj \<esc\> 是将 jk 或 kj 序列映射为退出插入模式的快捷键，这能节省宝贵的时间 。  
  * **代码哈希功能：** 手册中提到“选择区域然后输入Hash来哈希你的选择。这对于验证代码是否正确输入非常有用。”并提供了对应的Vim命令 ca Hash w\!cpp-dD-P-fpreprocessed tr \-d '\[:space:\]' | md5sum | cut \-c-6 。这个功能允许程序员对选定的代码区域进行哈希计算，并忽略所有空白字符和注释。这是一种高度专业化的技巧，用于快速验证代码片段是否与预期完全一致，从而避免因拼写错误或复制粘贴错误导致的细微bug。  
* **hash.sh 脚本：**  
  * \#Hashes a file, ignoring all whitespace and comments. Use for \#verifying that code was correctly typed.  
  * cpp-dD-P-fpreprocessed tr \-d '\[:space:\]' | md5sum | cut \-c-6：这个脚本与Vim中的哈希功能相辅相成，提供了在编辑器外部验证文件内容的机制。它通过预处理C++代码并移除所有空白和注释，然后计算其MD5哈希值的前6位，进一步确保代码的完整性和一致性 。

这些环境配置揭示了竞技编程中对效率和准确性的极致追求。一个配置良好的环境能够成为程序员思维的延伸，帮助他们尽早发现错误，自动化重复任务，从而将精力完全集中于问题解决本身。这突显了竞技编程中“工程师”的一面。

## **第二章 数学**

数学是竞技编程的基石，KTH手册提供了从基础方程到高级概率论和马尔可夫链的广泛数学工具。

### **2.1 方程**

手册首先列举了解决各类方程的基本方法，这些是许多算法问题的核心 。

* **二次方程：** 对于形如 ax2+bx+c=0 的二次方程，其解由公式 x=2a−b±b2−4ac​​ 给出。此外，二次函数的极值点位于 x=−b/2a 。在实际计算中，尤其是在浮点运算环境下，直接使用该公式可能会遇到精度问题，例如当 b2 与 4ac 非常接近时，可能导致有效数字损失。因此，在某些情况下，需要考虑使用替代形式或更高精度的数据类型（如long double）来保持数值稳定性。  
* **线性方程组：** 对于二元线性方程组 ax+by=e 和 cx+dy=f，其解为 x=ad−bced−bf​ 和 y=ad−bcaf−ec​ 。这种直接的解析解对于小型固定规模的系统非常方便。  
* **克莱姆法则：** 对于更一般的线性方程组 Ax=b，变量 xi​ 的解可以由克莱姆法则给出：xi​=detAdetAi′​​，其中 Ai′​ 是将矩阵 A 的第 i 列替换为向量 b 得到的矩阵 。虽然克莱姆法则在理论上提供了解，但对于大型系统，计算行列式通常效率较低（例如，使用高斯消元法计算行列式为 O(N3)，而直接解线性方程组也为 O(N3)）。因此，其在竞技编程中的应用更多限于概念理解或小型系统。

这些方程求解方法体现了竞技编程中对数学解析解的掌握，同时也暗示了在实际计算中需要权衡解析解的简洁性与数值算法的稳定性和效率。

### **2.2 递推关系**

递推关系是描述序列中项与前项之间关系的数学表达式，在组合数学和动态规划中扮演着重要角色 。

* **线性齐次递推关系：** 对于形如 an​=c1​an−1​+⋯+ck​an−k​ 的线性齐次递推关系，如果其特征方程 xk−c1​xk−1−⋯−ck​=0 有 k 个不同的根 r1​,…,rk​，那么通项公式为 an​=d1​r1n​+⋯+dk​rkn​ 。  
* **非重复根的处理：** 当特征方程存在非重复根 r 时，通项公式中对应项会包含多项式因子，例如 an​=(d1​n+d2​)rn 。

这些公式提供了递推关系的封闭形式解，使得 an​ 可以直接计算，而非迭代求值，从而将时间复杂度从 O(N) 降低到 O(1)（如果根和系数已知）。然而，在实际应用中，寻找高次多项式的根可能涉及复杂的数值计算。对于大 N 但小 k 的情况，通常会采用矩阵快速幂（O(k3logN)）或结合Berlekamp-Massey算法和线性递推计算（在数值算法章节中提及，时间复杂度更优）来高效地计算 an​ 的值，尤其是在模运算下。这表明，竞技编程中往往需要将数学理论与高效算法相结合，以解决实际计算问题。

### **2.3 三角学**

三角学是几何和物理问题中不可或缺的工具，手册中列出了常用的三角恒等式 。

* **角度加法公式：** 包含了 sin(v+w)、 cos(v+w) 和 tan(v+w) 的展开式。这些公式允许将复合角的三角函数转换为单角三角函数的组合 。  
* **和差化积公式：** 提供了 sin v+sin w 和 cos v+cos w 的转换公式。这些公式在简化表达式、求解特定值或将问题转换为更易处理的形式时非常有用 。  
* **正切定律：** (V+W)tan2v−w​=(V−W)tan2v+w​，其中 V,W 是与角度 v,w 相对的边长 。这个定律提供了边长与角度之间的一种替代关系，在某些特定几何问题中可能比正弦或余弦定律更为直接。  
* **波形叠加：** a cos x+b sin x=r cos(x−ϕ) 和 a sin x+b cos x=r sin(x+ϕ)，其中 r=a2+b2​ 且 ϕ=atan2(b,a) 。这个变换可以将两个相位不同的正弦/余弦波叠加为一个单一的、具有特定振幅和相位的波形。这在物理模拟、信号处理以及涉及旋转或周期现象的几何问题中非常有用。特别地，使用 atan2(b,a) 而非 atan(b/a) 可以正确处理所有象限的角度，避免了符号错误。

这些三角恒等式不仅是公式，更是解决问题时进行数学变换的工具。它们强调了在竞技编程中，识别何时应用特定变换来简化问题或揭示其隐藏结构的重要性。

### **2.4 几何**

几何学在竞技编程中占据重要地位，手册提供了2D和3D几何问题的全面公式集 。

#### **2.4.1 三角形**

手册详细列出了三角形的基本属性和相关公式 ：

* **边长：** a,b,c。  
* **半周长：** p=2a+b+c​。  
* **面积：** A=p(p−a)(p−b)(p−c)​ (海伦公式) 。  
* **外接圆半径：** R=4Aabc​ 。  
* **内切圆半径：** r=pA​ 。  
* **中线长度：** ma​=21​2b2+2c2−a2​ (中线定理) 。  
* **角平分线长度：** sa​=bc\[1−(b+ca​)2\]​ 。  
* **正弦定律：** asin α​=bsin β​=csin γ​=2R1​ 。  
* **余弦定律：** a2=b2+c2−2bc cos α 。  
* **正切定律：** a−ba+b​=tan2α−β​tan2α+β​​ 。

这些公式是解决三角形相关问题的基础，拥有这些预先推导好的公式可以节省大量时间，避免在比赛中临时推导的错误。

#### **2.4.2 四边形**

手册还提供了四边形的面积计算和特殊四边形的性质 ：

* **边长：** a,b,c,d。  
* **对角线：** e,f。  
* **对角线夹角：** θ。  
* **魔力通量 (Magic flux)：** F=b2+d2−a2−c2 。  
* **面积：** 4A=2ef⋅sin θ=F tan θ=4e2f2−F2​ 。这个“魔力通量”及其与四边形面积的关系是一个不常用但强大的公式，表明手册深入挖掘了几何特性。  
* **圆内接四边形：** 对角和为180°，对角线乘积 ef=ac+bd (托勒密定理)，面积 A=(p−a)(p−b)(p−c)(p−d)​ (婆罗摩笈多公式) 。识别圆内接四边形等特殊几何构型至关重要，因为它们通常具有更简单或更直接的公式。

#### **2.4.3 球坐标**

手册还包含了球坐标与笛卡尔坐标之间的转换公式 ：

* **笛卡尔坐标到球坐标：** r=x2+y2+z2​，θ=acos(z/x2+y2+z2​)，ϕ=atan2(y,x) 。  
* **球坐标到笛卡尔坐标：** x=r sin θ cos ϕ，y=r sin θ sin ϕ，z=r cos θ 。

球坐标的引入将几何工具扩展到三维空间，预示着可能存在涉及球面上点的问题。这部分内容强调了掌握一套丰富的几何公式，并识别特殊几何性质的重要性，这种“知识预计算”能显著加快问题解决速度。

### **2.5 导数与积分**

尽管竞技编程主要关注离散数学，但导数和积分在连续优化、概率密度函数和物理模拟中仍发挥着关键作用 。

* **常见导数：** 手册列出了反正弦、反余弦、正切和反正切函数的导数 。导数是寻找函数极值的基础，这在连续优化问题中至关重要。  
* **常见积分：** 包括正切函数、xsinax、e−x2 和 xeax 的积分 。积分在连续概率分布中用于计算概率或期望值。特别是 e−x2 的积分与正态分布的累积分布函数相关。  
* **分部积分法：** ∫ab​f(x)g(x)dx=\[F(x)g(x)\]ab​−∫ab​F(x)g′(x)dx 。这是一个通用的积分技巧，用于解决更复杂的积分问题。

这些微积分工具的包含，表明竞技编程问题并非总是纯粹离散的。掌握连续数学，特别是微积分，对于处理涉及连续变量、实数优化或概率分布的问题至关重要。

### **2.6 求和**

手册提供了常见序列的封闭形式求和公式，这些公式对于将时间复杂度从线性降低到常数级别至关重要 。

* **等比数列：** ca+ca+1+⋯+cb=c−1cb+1−ca​，其中 c=1 。  
* **等差数列：** 1+2+⋯+n=2n(n+1)​ 。  
* **平方和：** 12+22+⋯+n2=6n(2n+1)(n+1)​ 。  
* **立方和：** 13+23+⋯+n3=4n2(n+1)2​ 。  
* **四次方和：** 14+24+⋯+n4=30n(n+1)(2n+1)(3n2+3n−1)​ 。

这些封闭形式的求和公式直接提升了计算效率。例如，计算 1+2+⋯+n 迭代需要 O(N) 时间，而使用公式则仅需 O(1)。对于大规模输入的问题，这种效率提升往往是决定程序能否通过时间限制的关键。在竞技编程中，这些求和通常需要在模某个大素数下进行，此时除法需要替换为模逆元的乘法，这与数论中的模算术概念紧密相连。这部分内容强调了预先掌握特定数学公式能够将计算密集型操作转化为常数时间操作，是竞技编程中一项基本的优化策略。

### **2.7 级数**

手册中包含了常见函数的泰勒级数展开式，这些级数在函数逼近和渐近分析中发挥作用 。

* **常见函数泰勒级数：** 包括 ex、ln(1+x)、1+x​、sinx 和 cosx 的级数展开式 。

这些级数展开式对于难以直接计算或涉及复杂操作的函数（如超越函数）提供了精确的近似方法。在数值问题中，当精确解不可行或不必要时，足够精度的近似解便可满足要求。级数展开还能揭示函数在特定点（如 x 接近0）的行为，这对于理解极限、增长率以及设计依赖于函数局部行为的算法至关重要。虽然手册未明确提及，但这些级数也是生成函数的基础，而生成函数是组合数学中的强大工具。这部分内容表明，竞技编程问题可能需要超越精确算术的数值方法，理解如何使用级数逼近函数对于涉及连续数学、数值稳定性或处理可能导致溢出/下溢或精度问题的极大/极小数的问题至关重要。

### **2.8 概率论**

概率论是处理随机性和不确定性问题的基础，手册提供了离散和连续随机变量的期望值、方差以及常见分布的公式 。

* **离散随机变量：**  
  * 期望值（均值）μ=E(X)=∑x​xpX​(x)。  
  * 方差 σ2=V(X)=E(X2)−(E(X))2=∑x​(x−E(X))2pX​(x) 。  
* **连续随机变量：** 将求和替换为积分，概率质量函数 pX​(x) 替换为概率密度函数 fX​(x) 。  
* **期望的线性性质：** E(aX+bY)=aE(X)+bE(Y) 。这一性质极为强大，因为它无论随机变量是否独立都成立，常用于简化复杂的期望计算。  
* **独立变量的方差：** V(aX+bY)=a2V(X)+b2V(Y) 。

#### **2.8.1 离散分布**

手册列举了三种常见的离散概率分布 ：

* **二项分布 Bin(n,p)：** 描述 n 次独立试验中成功次数的概率。其概率质量函数为 p(k)=(kn​)pk(1−p)n−k，均值 μ=np，方差 σ2=np(1−p)。当 p 很小时，二项分布可近似为泊松分布 Po(np) 。  
* **首次成功分布 Fs(p)：** 描述在独立试验中首次成功所需试验次数的概率。其概率质量函数为 p(k)=p(1−p)k−1，均值 μ=p1​，方差 σ2=p21−p​ 。  
* **泊松分布 Po(λ)：** 描述在固定时间段内事件发生次数的概率。其概率质量函数为 p(k)=e−λk\!λk​，均值 μ=λ，方差 σ2=λ 。

#### **2.8.2 连续分布**

手册还包括了三种重要的连续概率分布 ：

* **均匀分布 U(a,b)：** 概率密度函数在区间 \[a,b\] 内为常数 f(x)=b−a1​，均值 μ=2a+b​，方差 σ2=12(b−a)2​ 。  
* **指数分布 Exp(λ)：** 描述泊松过程中事件间隔时间的概率。概率密度函数为 f(x)=λe−λx，均值 μ=λ1​，方差 σ2=λ21​ 。  
* **正态分布 N(μ,σ2)：** 广泛用于描述自然界中的随机现象。概率密度函数为 f(x)=2πσ2​1​e−2σ2(x−μ)2​。值得注意的是，如果 X1​∼N(μ1​,σ12​) 和 X2​∼N(μ2​,σ22​) 独立，那么它们的线性组合 aX1​+bX2​+c∼N(aμ1​+bμ2​+c,a2σ12​+b2σ22​) 。

这份详尽的概率论内容强调了概率建模的重要性。期望值和方差是核心概念，许多问题都要求计算某个量的期望值，这通常需要动态规划或直接应用期望的线性性质。特定分布的包含表明问题常可直接映射到这些标准模型，从而利用其已知性质进行高效计算。这部分内容突显了竞技编程不仅涉及确定性算法，也要求参赛者具备处理随机过程的能力。

### **2.9 马尔可夫链**

马尔可夫链是用于建模序列决策过程、随机游走和具有无记忆性转移系统的强大工具 。

* **定义与转移矩阵：** 马尔可夫链是一种离散随机过程，其下一个状态仅取决于当前状态。它由一个转移矩阵 P=(pij​) 定义，其中 pij​=Pr(Xn​=i∣Xn−1​=j) 表示从状态 j 转移到状态 i 的概率。经过 n 步后的概率分布由 P(n)=PnP(0) 给出，其中 P(0) 是初始分布 。这里对 Pn 的使用暗示了矩阵快速幂是计算多步概率的关键算法。  
* **平稳分布：** 如果存在一个概率分布 π 使得 π=πP，则称 π 为平稳分布。平稳分布描述了系统在长期运行后的稳定状态。对于不可约（即从任何状态都可以到达任何其他状态）的马尔可夫链，平稳分布的每个分量 πi​ 等于 1/E(Ti​)，其中 E(Ti​) 是两次访问状态 i 之间的期望时间。此外，πj​/πi​ 表示在两次访问状态 i 之间期望访问状态 j 的次数 。  
* **图上的特殊性质：** 对于连通、无向且非二分图，如果转移概率在所有邻居之间均匀分布，则平稳分布的 πi​ 与节点 i 的度数成比例 。这是一个针对图上随机游走的高度特定但非常有用的结果。  
* **遍历性 (Ergodicity) 与吸收链 (A-chain)：** 如果马尔可夫链的渐近分布与初始分布无关，则称其为遍历的。一个有限马尔可夫链是遍历的当且仅当它是不可约且非周期的（即所有循环长度的最大公约数为1）。在这种情况下，limk→∞​Pk=1π 。A-链是一种特殊的马尔可夫链，其状态可以分为吸收状态集合 A 和瞬时状态集合 G。在状态 j 开始时，被吸收在状态 i∈A 的概率为 aij​=pij​+∑k∈G​aik​pkj​。从状态 i 开始到被吸收的期望时间为 ti​=1+∑k∈G​pki​tk​ 。

马尔可夫链的引入标志着对动态系统建模和分析其长期行为的深入。它结合了线性代数、图论和概率论的概念，为解决涉及状态转移、随机游走和长期均衡的问题提供了强大的框架。

## **第三章 数据结构**

数据结构是算法的基石，KTH手册提供了多种高效的数据结构，以优化各类查询和操作。

### **3.1 序统计树**

序统计树是一种增强型的平衡二叉搜索树，它扩展了标准std::set的功能，支持高效的基于顺序的查询 。

* **核心功能：** 该数据结构允许在 O(logN) 时间内查找集合中的第 N 个元素 (find\_by\_order)，以及查找给定元素的索引或排名 (order\_of\_key) 。这些操作对于需要动态维护元素排名或进行K-th元素查询的问题至关重要。  
* **实现细节：** KTH手册中的实现使用了GNU扩展库\_gnu\_pbds::tree，这是一个策略基于的数据结构库，提供了比标准库更高级的功能和性能 。这种对编译器特定扩展的依赖，体现了竞技编程中为追求极致性能而作出的实用选择。  
* **合并操作：** join 操作允许高效地合并两个序统计树，这在需要动态拆分和合并集合的问题中非常有用 。

序统计树的引入，展示了通过增强标准库功能来解决特定查询需求的策略。它强调了在竞技编程中，了解并利用高级或非标准数据结构以实现最优性能的重要性。

### **3.2 哈希映射**

哈希映射是一种提供快速键值查找的数据结构。KTH手册提供了一个定制的哈希映射实现，旨在超越标准std::unordered\_map的性能 。

* **性能优势：** 该哈希映射声称比std::unordered\_map快约3倍，但内存使用量增加1.5倍 。这种性能提升通常通过更优化的底层实现（如线性探测）和对哈希冲突的更高效处理来实现。  
* **容量要求：** 初始容量必须是2的幂次方 。这一要求通常是为了简化哈希函数中的模运算，使其可以通过位运算实现，从而进一步提高速度。  
* **自定义哈希函数：** 采用了自定义的chash哈希函数，它通过 \_builtin\_bswap64(x \* C) 对键进行位混合，其中 C 是一个大的奇数 。这种位混合技术有助于改善整数键的哈希分布，尤其是在键的低位可能存在相关性时，从而减少哈希冲突，提升查找效率。

这个哈希映射的实现突出了在竞技编程中对常数因子优化的重视。对于哈希表操作成为性能瓶颈的问题，使用这种定制化的、更快的哈希映射实现，往往是解决“时间限制超出”问题的关键。它也反映了在性能敏感场景下，理解数据结构底层实现和权衡内存与性能的重要性。

### **3.3 线段树**

线段树是一种多功能的数据结构，用于在数组上执行范围查询和点更新 。

* **基本功能：** 手册中的线段树是一个零索引的最大值树，支持在 O(logN) 时间内进行点更新和范围查询 。  
* **可定制性：** 其设计具有高度灵活性，可以通过修改模板参数 T（存储的数据类型）、f（任意关联函数，如max、min、sum等）和 unit（f的单位元）来适应不同的问题需求 。这种通用性使得一个线段树模板可以解决多种范围查询问题，而无需进行大量代码修改。  
* **边界约定：** 范围查询的边界约定为左闭右开 。这种约定在C++中很常见，有助于避免边界错误，简化范围处理逻辑。

线段树的这种抽象化设计，通过将具体操作（如求和、求最大值）抽象为关联函数，极大地扩展了其应用范围。它鼓励参赛者将问题分解为可以在区间上高效组合的抽象函数，从而利用线段树的强大能力。

### **3.4 懒惰线段树**

懒惰线段树是标准线段树的扩展，它通过引入“懒惰标记”机制，能够高效地处理区间更新操作 。

* **核心功能：** 该数据结构支持对大区间进行值的添加或设置，并计算区间的最大值 。所有操作的时间复杂度均为 O(logN)。  
* **懒惰传播原理：** 传统线段树的区间更新操作可能需要访问并更新区间内的所有叶子节点，导致效率低下。懒惰线段树通过在父节点上存储一个“懒惰标记”来延迟更新操作的下推。只有当需要访问或查询子节点时，这些标记才会被“下推”到子节点，从而显著减少了实际更新的节点数量 。push() 方法是实现这一机制的关键，它负责将父节点的懒惰标记传播给其子节点。  
* **性能优化建议：** 手册特别指出，“为了更好的性能，请与碰撞分配器（bump allocator）配合使用，并使用SmallPtr或隐式索引来节省内存” 。动态分配节点（如使用new Node(...)）可能会因内存分配器的开销而变慢。碰撞分配器提供极快的内存分配速度，而SmallPtr（或使用数组索引而非指针）则通过减少指针大小或完全消除指针来节省内存，这对于大型线段树而言至关重要。

懒惰传播是优化树形数据结构区间操作的基本技术。这部分内容强调了高级数据结构实现中，通过延迟工作和精细化内存管理来达到最优性能的策略。

### **3.5 可回滚并查集**

可回滚并查集是一种增强型的并查集（Disjoint-Set Union, DSU）数据结构，它在支持高效的集合合并与查找操作的同时，还具备撤销（rollback）功能 。

* **核心功能：** 除了标准的 find（查找元素所属集合的代表元）和 join（合并两个集合）操作外，该数据结构还提供了 time()（记录当前操作时间点）和 rollback(t)（回滚到指定时间点的状态）功能 。所有操作的时间复杂度均为 O(logN)。  
* **实现机制：** 回滚功能通过维护一个操作栈 st 来实现。每次对并查集内部状态（如父节点数组 e）进行修改时，旧值和其索引会被压入栈中。当需要回滚时，栈中的操作会按逆序弹出并恢复状态 。这种实现通常不使用完全的路径压缩（因为路径压缩会破坏回滚能力），而是依赖于按秩合并或按大小合并来保证树的深度，从而维持对数时间复杂度。  
* **应用场景：** 这种数据结构特别适用于需要处理“离线查询”（即所有查询预先已知）或涉及分治算法的问题，其中在处理子问题后需要恢复到之前的状态。例如，在处理带时间限制的图连通性问题时，可回滚并查集能够高效地管理图的动态变化。

可回滚并查集的引入，展示了数据结构如何被设计以处理时间维度上的操作，允许高效地查询历史状态或进行回溯。这对于需要探索不同历史配置的动态问题而言是一个强大的工具。

### **3.6 子矩阵求和**

子矩阵求和是一种利用二维前缀和技术快速计算矩阵任意矩形区域和的方法 。

* **核心功能：** 给定矩阵的左上角和右下角坐标（左闭右开），该数据结构能够快速计算指定子矩阵的元素和 。  
* **实现原理：** 通过预处理一个二维前缀和矩阵 p，其中 p\[r+1\]\[c+1\] 存储了原始矩阵中 (0,0) 到 (r,c) 矩形区域的和。p\[r+1\]\[c+1\] \= v\[r\]\[c\] \+ p\[r\]\[c+1\] \+ p\[r+1\]\[c\] \- p\[r\]\[c\] 。查询任意子矩阵的和时，可以通过四个前缀和值进行加减运算，遵循二维容斥原理。  
* **时间复杂度：** 预处理阶段需要 O(N2) 时间（其中 N 是矩阵的维度），而每次查询仅需 O(1) 时间 。这种高效性使其非常适用于需要进行大量子矩阵求和查询的问题。

子矩阵求和是前缀和技术在二维空间上的直接扩展。它展示了一个通用原则：许多一维数据结构和算法可以被推广到更高维度，通常通过迭代应用相同逻辑或利用容斥原理来实现。这是解决网格类问题的基础技术。

### **3.7 矩阵**

矩阵是线性代数中的核心概念，在竞技编程中常用于解决线性递推、图路径计数等问题 。

* **基本操作：** KTH手册中的Matrix模板支持方阵的基本操作，特别是矩阵乘法和矩阵快速幂。矩阵乘法通过嵌套循环实现，时间复杂度为 O(N3) 。  
* **矩阵快速幂：** operator^ 实现了矩阵的快速幂运算，能够在 O(N3logp) 的时间复杂度内计算矩阵的 p 次幂 。这与模幂运算中的二分快速幂原理相同，将幂次 p 分解为二进制形式，通过重复平方和乘法来完成。  
* **应用场景：**  
  * **线性递推：** 许多线性递推关系（如斐波那契数列）可以转化为矩阵乘法的形式，通过矩阵快速幂高效计算第 N 项。  
  * **图路径计数：** 如果一个图的邻接矩阵为 A，那么 Ak 的元素 Ak\[i\]\[j\] 表示从节点 i 到节点 j 长度为 k 的路径数量。这可以扩展到带权图和最短路径问题。

矩阵及其操作，特别是矩阵快速幂，是强大的算法工具。它们将看似迭代或组合的问题转化为代数形式，并通过高效的指数运算来解决。

### **3.8 凸包技巧**

凸包技巧（Convex Hull Trick, CHT）是一种优化动态规划问题的技术，它将线性函数的最优化问题转化为几何问题 。

* **核心功能：** Line Container 数据结构允许添加形如 kx+m 的直线，并查询在特定点 x 处的最大值 。其时间复杂度为 O(logN)。  
* **动态规划优化：** CHT 适用于形如 DP\[i\]=minj\<i​(f(j)+mj​⋅xi​) 的动态规划转移方程。其中，每个 mj​⋅xi​+f(j) 可以看作一条直线。问题转化为在给定 xi​ 处找到一组直线中的最小值（或最大值）。  
* **几何原理：** 如果斜率 mj​ 和/或查询点 xi​ 具有单调性，那么这些直线的下包络线（或上包络线）将形成一个凸包（或凹包）。通过维护这个凸包，可以在对数时间内找到最优直线。  
* **实现细节：** 通常使用 multiset 或双端队列来维护凸包上的直线，并利用直线的交点来判断哪些直线是冗余的或何时切换最优直线 。  
* **数值稳定性：** 手册中强调了处理大整数时数值稳定性的重要性，例如 div 函数用于处理向下取整的除法，以及使用 LLONG\_MAX 表示无穷大，以避免整数溢出 。

凸包技巧是几何学应用于优化非几何问题的典型案例，它展示了高级竞技编程技术中跨学科的性质，以及识别潜在数学结构的重要性。

### **3.9 Treap**

Treap 是一种随机化的平衡二叉搜索树，它结合了二叉搜索树（BST）和堆（Heap）的特性 。

* **数据结构特性：** Treap 作为一个序列容器，支持在 O(logN) 期望时间内进行分裂（split）和合并（merge）操作，并且易于进行额外数据（如子树大小）的增强 。  
* **平衡机制：** 每个节点包含一个值（val）和一个随机优先级（y）。Treap 满足两个条件：首先，它是一个关于节点值 val 的二叉搜索树（左子树的值小于根节点，右子树的值大于根节点）；其次，它是一个关于随机优先级 y 的最大堆（父节点的优先级大于子节点） 。这种双重排序确保了树的概率性平衡，避免了退化为链表的情况。  
* **核心操作：** split 操作将一个Treap 分裂成两个Treap，一个包含所有小于给定键的节点，另一个包含所有大于给定键的节点。merge 操作则将两个Treap 合并为一个。这些操作相对简单，且能保持堆属性，从而保证了对数期望时间复杂度 。  
* **增强能力：** 由于 split 和 merge 操作的简洁性，在这些操作过程中更新节点中的聚合信息（例如子树大小 c）变得非常容易，从而支持范围查询（如范围和、范围最大值等）。

Treap 的引入展示了随机化在算法设计，特别是数据结构中的强大作用。它表明概率性保证通常能带来更简单的实现和良好的平均性能，这对于开发时间有限的竞技编程环境非常有利。

### **3.10 树状数组**

树状数组（Fenwick Tree，也称为Binary Indexed Tree, BIT）是一种高效的数据结构，用于处理数组上的点更新和前缀和查询 。

* **核心功能：** 它支持在 O(logN) 时间内更新数组中的单个元素 a\[i\]（通过记录新旧值之间的差值），以及在 O(logN) 时间内计算前缀和 a+a+⋯+a\[pos−1\] 。  
* **位运算的精妙：** 树状数组的核心在于其巧妙地利用了位运算。pos & \-pos 操作能够提取 pos 的最低有效位（Least Significant Bit, LSB），这对应于隐式树结构中节点所覆盖区间的长度。更新和查询操作通过 pos \+= pos & \-pos 和 pos \-= pos & \-pos 等位运算来高效地在树结构中导航。  
* **lower\_bound 扩展：** 手册中还包含了一个 lower\_bound 函数，用于查找最小的 pos，使得 sum(0, pos) 大于等于给定 sum 。这个扩展功能通过在树状数组结构上进行二分查找实现，通常用于解决诸如动态数组中查找第K小元素等问题。

树状数组的引入，突显了位运算在设计高效且紧凑数据结构方面的精妙之处。它是处理动态前缀和或频率查询问题的基本工具。

### **3.11 二维树状数组**

二维树状数组是树状数组在二维空间上的扩展，用于高效处理矩阵上的点更新和矩形区域求和查询 。

* **核心功能：** 它支持增加单个元素 a\[i\]\[j\] 的值，并计算所有 i \< L, j \< J 的 a\[i\]\[j\] 的和 。  
* **时间复杂度：** 更新和查询操作的时间复杂度均为 O(log2N) 。  
* **离线处理优化：** 该实现要求在初始化之前预先知道所有要更新的元素 (fakeUpdate 在 init() 之前调用)。fakeUpdate(x, y) 会收集给定 x 坐标下所有将要更新的 y 坐标。init() 函数则对这些 y 坐标进行排序，并为每个 x 坐标构建一个一维树状数组 。这种“离线处理”方法实际上是对 y 维度进行了坐标压缩，使得内部的树状数组可以处理稀疏数据，从而提高效率。如果更新是完全在线的（即任意 x,y 随时可更新），则需要更复杂的数据结构（如持久化线段树）来实现。  
* **替代方案：** 手册中提到“使用持久化线段树可以实现 O(logN) 的时间复杂度” 。这暗示了对于完全在线的二维范围查询，持久化线段树是一个更先进但通常也更复杂的选择，它在实现复杂度和查询性能之间存在权衡。

二维树状数组的引入，展示了将一维数据结构扩展到更高维度的常见模式，以及利用离线处理技术来简化和优化数据结构的方法。

### **3.12 范围最小值查询 (RMQ)**

范围最小值查询（Range Minimum Query, RMQ）是一种用于在静态数组上进行高效范围查询的数据结构 。

* **核心功能：** RMQ 能够在常数时间 O(1) 内返回数组中指定范围 \[a, b) 内的最小值，前提是经过 O(NlogN) 的预处理 。  
* **稀疏表 (Sparse Table)：** 该实现采用了稀疏表技术。jmp\[k\]\[j\] 数组存储了从索引 j 开始、长度为 2k 的区间内的最小值。任何范围 \[a, b) 都可以被分解为两个重叠的、长度为 2dep 的子区间（其中 dep \= floor(log2(b-a))），然后取这两个子区间的最小值即可。这种方法之所以有效，是因为最小值操作是幂等的（即 min(x, x) \= x） 。  
* **性能优化：** 使用 \_builtin\_clz（count leading zeros）这一GCC编译器内置函数，可以快速计算 floor(log2(x))，从而在常数时间内确定 dep 值，进一步优化了查询的常数因子 。

RMQ的引入强调了针对不同查询模式（静态与动态、点查询与范围查询）选择最合适数据结构的重要性。对于静态数组上的范围查询，稀疏表提供了最优的查询时间复杂度，体现了“工欲善其事，必先利其器”的原则。

## **第四章 数值算法**

数值算法在竞技编程中占据重要地位，尤其是在处理浮点数精度、连续函数优化以及涉及大型矩阵运算的问题时。本章将探讨KTH手册中提供的数值算法工具。

### **4.1 多项式与递推**

本节提供了一套处理多项式和序列生成的算法工具，涵盖了从解析到数值以及模式识别的多种方法 。

* **多项式 (Polynomial)：** Poly 结构体用于表示多项式，其系数存储在 vector\<double\> a 中。它支持多项式求值（operator()）、求导（diff()）和通过根进行除法（divroot()） 。divroot() 实现了综合除法，对于找到一个根后降低多项式次数至关重要，从而使求根过程可以迭代进行。  
* **多项式求根 (PolyRoots)：** 该函数用于寻找多项式的实根。它采用数值方法，通过在导数根（即极值点）之间进行二分查找来确定根的区间 。其时间复杂度为 O(n2log(1/ϵ))，反映了迭代过程和对精度的要求。  
* **多项式插值 (PolyInterpolate)：** 给定 n 个点 (x\[i\],y\[i\])，该函数能够计算一个通过这些点的 n−1 次多项式 。其时间复杂度为 O(n2)，与拉格朗日或牛顿插值法的标准复杂度一致。手册中关于“数值精度”和“k\*cos(k/(n-1)+pi)”的提示，暗示了使用特定 x 值（如切比雪夫节点）可以最小化龙格现象，提高数值插值的稳定性。  
* **Berlekamp-Massey 算法：** 该算法能够从一个序列的前 2n 项中恢复任意 n 阶线性递推关系 。它在发现未知递推模式时非常有用，例如在暴力计算出序列前几项后，利用此算法推断递推式。其 O(N2) 的时间复杂度使其在实际中具有可行性，并且该算法适用于任意域（如模素数域）。  
* **线性递推 (Linear Recurrence)：** 该函数用于计算已知 n 阶线性递推关系的第 k 项，给定初始项 S\[0…n−1\] 和转移系数 tr\[0…n−1\] 。其时间复杂度为 O(n2logk)，比直接的矩阵乘法更快，尤其是在 n 较小时。其核心在于一个类似矩阵快速幂的优化过程，通过多项式乘法和约减来高效计算。

这一系列算法表明，竞技编程问题往往需要深入理解多项式和序列，不仅要掌握其数学性质，还要能够进行高效的计算操作，包括精确的代数方法、稳健的数值逼近以及模式发现。

### **4.2 优化**

优化是寻找函数最优解或满足特定约束的最佳配置的过程。本节提供了针对不同优化问题的算法 。

* **黄金分割搜索 (Golden Section Search)：** 该算法用于在给定区间 \[a,b\] 内寻找单峰函数 f 的最小值（或最大值）。它通过不断缩小搜索区间，最终收敛到极值点。其时间复杂度为 O(log((b−a)/ϵ))，其中 ϵ 是所需精度 。这是一种确定性且收敛性有保证的搜索方法。  
* **爬山算法 (Hill Climbing)：** 作为一种简易的优化方法，爬山算法适用于单峰函数。它通过在当前点附近进行局部搜索，并朝着目标函数值改善的方向移动，直到达到局部最优 。由于其贪婪性质，如果函数存在多个局部最优解，爬山算法可能会陷入其中而无法找到全局最优解。其包含表明在某些问题中，近似解或局部最优解可能已足够，或者问题结构保证了单峰性。  
* **数值积分 (Integrate, Integrate Adaptive)：**  
  * Integrate 使用辛普森法则对函数进行数值积分，误差与步长的四次方成比例 。  
  * Integrate Adaptive 采用自适应辛普森法则，根据函数的局部行为动态调整步长，从而在不同平滑度的函数上提供更高的效率和精度 。这种自适应性是数值分析中提高性能和精度的常见策略。  
* **单纯形法 (Simplex)：** 该算法用于解决一般的线性规划问题：在满足 Ax≤b,x≥0 等线性约束下，最大化目标函数 cTx 。单纯形法是运筹学中的核心算法。手册中特别指出“数值稳定性不保证”，这是一个重要的警告，意味着浮点精度问题可能对单纯形法的实现造成影响，特别是在处理退化情况时。其时间复杂度通常表示为 O(NM⋅pivots)，其中 pivots 表示枢轴操作的次数，在实际应用中通常是多项式时间，尽管理论最坏情况可能是指数级的。

这些优化算法涵盖了不同的优化范式。参赛者需要区分可以通过梯度方法、单峰函数直接搜索或线性规划解决的问题，并了解浮点实现中可能面临的数值稳定性挑战。

### **4.3 矩阵**

矩阵运算是线性代数的核心，在竞技编程中广泛应用于解决方程组、变换以及图论问题 。

* **行列式 (Determinant, Int Determinant)：**  
  * Determinant 计算浮点数矩阵的行列式，时间复杂度为 O(N3)，但会破坏原始矩阵 。浮点运算可能存在精度问题。  
  * Int Determinant 计算整数矩阵在模数下的行列式，同样是 O(N3) 。这种模数算术确保了结果的精确性，对于需要精确计数的组合问题至关重要。  
* **线性方程组求解 (SolveLinear, SolveLinear2, SolveLinear Binary)：**  
  * SolveLinear 使用高斯消元法解决 Ax=b 形式的线性方程组，返回矩阵的秩，或在无解时返回 \-1。它会修改输入矩阵 A 和向量 b 。  
  * SolveLinear2 是 SolveLinear 的一个变体，旨在从解决方案中提取所有唯一确定的变量值，即使系统存在多重解也适用 。  
  * SolveLinear Binary 专门用于在 F2​（即模2运算）上解决 Ax=b。这对于涉及异或和、基向量或线性编码的问题至关重要，因为其中的元素都是二进制位。使用 bitset 存储行向量可以优化内存和速度 。  
* **矩阵求逆 (MatrixInverse)：** 该函数用于计算矩阵 A 的逆矩阵，时间复杂度为 O(N3)。它返回矩阵的秩；如果矩阵是奇异的（秩小于 N），则无法求逆。手册中提到可以扩展到素数模，例如使用 A^{-1} \= A^{-1}(2I-AA^{-1}) \\pmod{p^k} 进行迭代，这暗示了Hensel Lifting等高级技术 。  
* **三对角矩阵求解 (Tridiagonal)：** 专门用于解决三对角方程组，其时间复杂度仅为 O(N) 。相比于一般高斯消元的 O(N3)，这是一个巨大的性能提升，因为它充分利用了矩阵的稀疏结构。该算法在数值方法中常用于求解微分方程或特定类型的递推关系。

本节强调了竞技编程不仅需要掌握通用的线性代数算法，还需要了解何时应用特殊版本（例如模算术、特定域如 F2​、或结构化矩阵如三对角矩阵），以达到所需的效率或精度。

### **4.4 傅里叶变换**

傅里叶变换及其变体是高效计算卷积、多项式乘法以及其他复杂操作的基石，在高级组合学和信号处理问题中发挥着核心作用 。

* **快速傅里叶变换 (Fast Fourier Transform, FFT)：** fft(a) 函数计算序列 a 的离散傅里叶变换 f^​(k)=∑x​a\[x\]exp(2πi⋅kx/N)。它主要用于高效地执行卷积操作 conv(a, b)，其中 N 必须是2的幂次。时间复杂度为 O(NlogN) 。手册中特别提醒了浮点精度问题，并给出了一个安全范围：当 (∑ai2​+∑bi2​)log2​N\<9⋅1014 时，舍入是安全的。  
* **模数快速傅里叶变换 (Fast Fourier Transform Mod)：** 这是一个高精度的FFT变体，可用于在任意整数模 M 下进行卷积计算，只要 Nlog2​N⋅M\<8.6⋅1014 。它通过将大整数拆分为多个部分，然后对每个部分进行FFT，最终组合结果来克服标准FFT的浮点精度限制和数论变换（NTT）的模数限制。  
* **数论变换 (Number Theoretic Transform, NTT)：** ntt(a) 计算 f^​(k)=∑x​a\[x\]gxk，其中 g 是模数的原根。NTT 是 FFT 的整数算术等价物，它完全避免了浮点数问题，但要求模数是一个“友好”的素数，形式为 k⋅2a+1，且卷积结果的大小不超过 2a 。手册中列举了一些常用的“友好”素数。  
* **快速子集变换 (Fast Subset Transform, FST)：** FST 是一种广义的傅里叶变换，用于处理基于位运算（AND、OR、XOR）的卷积，即 c\[z\]=∑s=x⊕y​a\[x\]⋅b\[y\]。输入数组的大小必须是2的幂次。时间复杂度为 O(NlogN) 。

这些变换算法的核心思想都是卷积定理：在某个域中的卷积操作，在变换域中变为逐点乘法。这使得原本 O(N2) 的卷积操作可以在 O(NlogN) 时间内完成。本节揭示了许多看似不同的问题（如多项式乘法、组合求和、子集和）都可以通过变换方法统一并高效解决，前提是底层操作是卷积。它强调了理解不同卷积的数学性质以及选择适当变换（复数、模数、数论或子集）的重要性。

## **第五章 数论**

数论是竞技编程中不可或缺的领域，尤其在处理大整数、模运算和素数相关问题时。本章将深入探讨KTH手册中提供的数论工具。

### **5.1 模算术**

模算术是竞技编程中无处不在的基础运算，本节提供了其基本操作和高级算法 。

* **模运算结构体 (Modular Arithmetic)：** Mod 结构体封装了模加、模减、模乘、模除和模幂等运算符，确保所有算术操作自动在指定模数下进行 。这种封装模式有助于防止错误并提高代码清晰度。  
* **大数模乘 (ModMulLL)：** 能够计算 a⋅b(modc)，其中 a,b,c 可以高达 7.2⋅1018 。该函数利用了GCC扩展的 \_\_uint128\_t 类型，以处理中间乘积可能超过 264−1 的情况，确保在大整数模乘中的精确性。  
* **模平方根 (ModSqrt)：** 实现了Tonelli-Shanks算法，用于求解 x2≡a(modp) 的模平方根 。在最坏情况下，其时间复杂度为 O(log2p)，但在大多数素数 p 下为 O(logp)。它在处理二次剩余问题时非常有用。  
* **模幂 (ModPow)：** 高效计算 be(modmod)，时间复杂度为 O(loge) 。这是通过二分快速幂（或称平方求幂）实现的。  
* **模对数 (ModLog)：** 寻找最小的正整数 x 使得 ax≡b(modm)。该函数实现了 O(m​) 的Baby-step Giant-step算法，适用于模数 m 较小的情况 。  
* **模和 (ModSum)：** 计算模运算下的等差数列求和，即 ∑(ki+c)(modm)。其时间复杂度为 O(logm)，这得益于其内部可能使用了类似欧几里得算法的优化步骤 。

本节强调了竞技编程中对精确整数算术和高度专业化模运算的需求。它展示了如何利用编译器扩展或高级数论算法来处理大数运算、模平方根、离散对数和特殊求和，以确保精度和效率。

### **5.2 素性检验**

素性检验是数论中的基本问题，本节提供了两种高效的素数判断方法 。

* **快速埃拉托斯特尼筛法 (Fast Eratosthenes)：** 这是一种用于生成小于给定上限 LIM 的所有素数的筛法。对于 LIM=1e6，其运行时间约为1.5秒 。该实现利用 bitset 优化内存使用，将空间复杂度降至 O(LIM/8) 字节。其内部可能采用了分段筛法或轮式分解等优化，以处理更大的 LIM。这种方法适用于需要大量小素数的情况。  
* **米勒-拉宾素性检验 (Miller Rabin)：** 这是一种确定性素性检验算法，对于高达 7⋅1018 的数字，其结果是保证正确的 。这意味着在 unsigned long long 范围内，该测试是可靠的，而非概率性的。算法利用了费马小定理和二次探测定理，通过对一组特定基数进行测试来判断一个数是否为素数。其时间复杂度约为模幂运算的7倍，即 O(logN)。这种方法适用于检查单个大数的素性。

本节内容突显了根据问题约束选择算法的重要性：需要大量小素数时使用筛法，而需要判断少数大数的素性时则使用米勒-拉宾检验。

### **5.3 因数分解**

因数分解是将一个合数分解为其素数因子的过程，本节提供了相关的算法和数论定理 。

* **Pollard-rho 算法：** 这是一种随机化的因数分解算法，用于寻找一个数的素数因子。它能够返回一个数的所有素数因子，顺序任意 。其平均时间复杂度为 O(N1/4)，使其对于 long long 范围内的数具有实用性。该算法通常与米勒-拉宾素性检验结合使用，以确保找到的因子是素数。  
* **5.3.1 贝祖等式 (Bézout's Identity)：** 对于非零整数 a 和 b，存在整数解 x 和 y 使得 ax+by=gcd(a,b)，其中 gcd(a,b) 是 a 和 b 的最大公约数。这是能够表示为 ax+by 形式的最小正整数。如果 (x,y) 是一个解，那么所有解都可以表示为 (x+gcd(a,b)kb​,y−gcd(a,b)ka​)，其中 k∈Z 。  
* **欧几里得算法 (euclid)：** 该函数实现了扩展欧几里得算法，不仅计算 gcd(a,b)，还找到满足贝祖等式的整数 x 和 y 。如果 a 和 b 互质，那么 x 就是 a 在模 b 意义下的乘法逆元，这对于模除法至关重要。  
* **中国剩余定理 (CRT)：** crt(a, m, b, n) 函数用于求解同余方程组 z≡a(modm) 和 z≡b(modn)。如果 m 和 n 互质，它将计算出满足条件的唯一解 z，且 0≤z\<lcm(m,n)。该实现假设 mn\<262，时间复杂度为 O(logn) 。CRT 在需要组合多个模约束的问题中非常有用。  
* **欧拉函数 (phiFunction)：** ϕ(n) 定义为小于 n 且与 n 互质的正整数的数量。其性质包括 ϕ(1)=1，对于素数 p 和正整数 k，ϕ(pk)=(p−1)pk−1；如果 m,n 互质，则 ϕ(mn)=ϕ(m)ϕ(n)。更一般地，如果 n 的素因子分解为 p1k1​​p2k2​​…prkr​​，则 ϕ(n)=n⋅∏p∣n​(1−1/p) 。欧拉定理指出，如果 a,n 互质，则 aϕ(n)≡1(modn)。费马小定理是其特例：如果 p 是素数，则 ap−1≡1(modp)。手册中还包含了一个 calculatePhi() 函数，可以预计算一定范围内的 ϕ 值，这在需要频繁查询欧拉函数值时非常有用 。

本节内容深入探讨了数论的结构性方面，提供了分解数字和解决模关系问题的工具。这些工具使得解决需要寻找特定整数解、组合模约束或处理模幂运算的问题成为可能。

### **5.4 分数**

本节探讨了在竞技编程中处理有理数、寻找最佳近似以及在分数空间中进行搜索的方法 。

* **连分数 (Continued Fractions)：** 该方法用于给定一个实数 x\>0 和一个上限 N，寻找最接近 x 的有理近似 p/q，其中 p,q≤N 。这种近似满足 ∣p/q−x∣≤1/(qN)。连分数收敛子的性质是其交替地小于和大于被近似的实数。其时间复杂度为 O(logN)。在浮点精度不足以表示精确实数解的问题中，连分数提供了一种高精度的有理近似方法。  
* **分数二分搜索 (FracBinarySearch)：** 该算法用于在 $$ 区间内寻找最小的分数 p/q，使得某个条件函数 f(p/q) 为真，且 p,q≤N 。这里的“二分搜索”并非简单的数值二分，而是在法雷序列（Farey sequences）或斯特恩-布罗科特树（Stern-Brocot tree）的隐式结构上进行的搜索，这些结构能够有序地枚举所有不可约分数。其时间复杂度为 O(logN)。

这部分内容表明，竞技编程问题可能需要超越整数或简单浮点算术的范畴，需要复杂的有理数处理和搜索方法，尤其是在精度或特定分数性质至关重要时。

### **5.5 勾股数**

勾股数（Pythagorean Triples）是指满足 a2+b2=c2 的三个正整数 (a,b,c)。手册提供了生成所有勾股数的公式 。

* **生成公式：** 所有的勾股数都可以由以下公式唯一生成：a=k⋅(m2−n2)，b=k⋅(2mn)，c=k⋅(m2+n2) 。  
* **参数条件：** 这些公式的参数需要满足特定条件：m\>n\>0，k\>0，m 和 n 互质（m⊥n），且 m 或 n 中有一个是偶数 。当 k=1 时，这些公式生成所有原始勾股数（即 a,b,c 互质的勾股数）。通过改变 k 的值，可以得到所有非原始勾股数。

这个生成公式是数论中一个经典的构造性例子，它能够系统地生成特定类型的整数解。在需要枚举或检查特定范围内所有勾股数性质的问题中，这种公式比暴力搜索或测试更为高效。

### **5.6 素数性质**

本节提供了关于素数的一些实用常数和理论性质，特别是在哈希和模算术应用中 。

* **哈希用素数：** 手册列举了一些特定的大素数，例如 962592769（满足 221∣p−1，可能适用于数论变换NTT），970592641（31位），31443539979727（45位），3006703054056749（52位） 。这些素数因其大小和特定结构而被选作多项式哈希的模数，有助于减少哈希冲突。  
* **素数数量：** 提到了小于 1,000,000 的素数有 78498 个 。这个具体数字在估计筛法算法的循环次数或内存需求时非常有用。  
* **原根 (Primitive Roots)：** 阐述了原根的存在性：除了 p=2,a\>2 的情况外，原根存在于模任意素数幂 pa 下，且原根的数量为 ϕ(ϕ(pa)) 。原根是离散对数和数论变换（NTT）的关键。对于 p=2,a\>2 的特殊情况，群 Z2a×​ 同构于 Z2​×Z2a−2​，这是一个重要的理论细节。

本节内容揭示了竞技编程中对素数的双重需求：既需要实用的“常数”（如好的哈希模数），也需要对数论理论（如原根）有细致的理解，以解决涉及模算术和密码学相关性质的高级问题。

### **5.7 估计**

本节提供了一些关于数论函数增长率的估计，这些估计对于算法的复杂度分析和资源分配至关重要 。

* **∑d∣n​d=O(nloglogn)：** 这个估计通常与莫比乌斯反演或狄利克雷卷积相关，它给出了一个数的所有因子之和的渐近上界 。  
* **约数数量估计：** 手册给出了不同范围内的数，其约数数量的大致估计：  
  * n\<5⋅104 时，约数数量最多约 100 个。  
  * n\<107 时，约数数量最多约 500 个。  
  * n\<1010 时，约数数量最多约 2000 个。  
  * n\<1019 时，约数数量最多约 200,000 个 。

这些估计对于设计算法时判断循环次数、数据结构大小以及预估运行时间非常有用。例如，如果一个算法的复杂度依赖于一个数的约数数量，那么这些估计可以帮助判断算法在给定输入范围内的可行性。它们强调了在竞技编程中，对函数增长率和资源消耗的准确估计是优化和选择算法的关键。

### **5.8 莫比乌斯函数**

莫比乌斯函数 μ(n) 是数论中一个重要的乘性函数，在容斥原理和数论函数求和中扮演关键角色 。

* **定义：**  
  * 如果 n 包含平方因子，则 μ(n)=0。  
  * 如果 n 是无平方因子数，且有偶数个素因子，则 μ(n)=1。  
  * 如果 n 是无平方因子数，且有奇数个素因子，则 μ(n)=−1 。  
* **莫比乌斯反演公式：**  
  * 如果 g(n)=∑d∣n​f(d)，则 f(n)=∑d∣n​μ(d)g(n/d) 。这是最常用的形式，它允许从一个求和函数中反演出原始函数。  
  * 一个非常有用的性质是 ∑d∣n​μ(d)=\[n=1\]，即只有当 n=1 时和为1，否则为0 。  
  * 其他形式：  
    * 如果 g(n)=∑n∣d​f(d)，则 f(n)=∑n∣d​μ(d/n)g(d) 。  
    * 如果 g(n)=∑1≤m≤n​f(⌊n/m⌋)，则 f(n)=∑1≤m≤n​μ(m)g(⌊n/m⌋) 。

莫比乌斯函数的引入，揭示了数论在解决组合计数问题中的深度。它特别适用于那些涉及最大公约数（GCD）或对约数求和的问题，通过容斥原理将复杂求和转化为更易处理的形式。

## **第六章 组合数学**

组合数学是研究离散对象计数、排列、组合及其性质的数学分支。KTH手册提供了从基本计数原理到高级组合序列的广泛工具。

### **6.1 排列**

排列是组合数学中的基本概念，本节涵盖了排列相关的计数和性质。

#### **6.1.1 阶乘**

阶乘 n\! 表示从 n 个不同元素中取出 n 个元素进行全排列的方法数。手册提供了一张阶乘数值表，展示了其快速增长的特性 。例如，10\!=3,628,800，而 17\! 已达到 3.6⋅1014，超过了 long long 的安全范围，并且 171\! 已经超过了 DBL\_MAX（双精度浮点数的最大值） 。这提醒了在处理大阶乘时需要考虑模运算或高精度计算。

* **排列到整数转换 (IntPerm.h)：** 该模块提供了将一个排列转换为一个整数表示的方法，但这种转换不保留顺序。其时间复杂度为 O(n) 。这种转换在某些需要将排列作为状态或索引的问题中非常有用。

#### **6.1.2 循环**

本节讨论了排列的循环分解。

* **具有特定循环长度的排列计数：** 令 gS​(n) 表示 n 个元素的排列中，所有循环长度都属于集合 S 的排列数量。其指数生成函数为 ∑n=0∞​gS​(n)n\!xn​=exp(∑n∈S​n\!xn​) 。这个公式是组合学中指数生成函数的一个强大应用，用于解决具有特定结构约束的排列计数问题。

#### **6.1.3 错排**

错排是指一个集合的排列，使得没有元素出现在其原始位置。

* **错排数量 D(n)：** 错排数量的递推关系为 D(n)=(n−1)(D(n−1)+D(n−2))，且 D(n)=nD(n−1)+(−1)n 。其封闭形式为 D(n)=n\!e−1（四舍五入到最近的整数）。

#### **6.1.4 Burnside引理**

Burnside引理是群论在组合计数中的应用，用于计算在特定对称群作用下不同配置的数量。

* **引理公式：** 给定一个对称群 G 和一个集合 X，在对称性下 X 中元素的数量等于 ∣G∣1​∑g∈G​∣Xg∣，其中 Xg 是被群元素 g 固定（即 g⋅x=x）的元素集合 。  
* **旋转对称性：** 如果 f(n) 计算长度为 n 的“配置”数量，并且我们希望忽略旋转对称性（使用群 Zn​），则不同的配置数量为 g(n)=n1​∑k=0n−1​f(gcd(n,k))=n1​∑k∣n​f(k)ϕ(n/k) 。这在图论或字符串问题中，需要计数本质上不同的环形结构时非常有用。

### **6.2 划分与子集**

本节探讨了整数划分和二项式系数的相关概念。

#### **6.2.1 划分函数**

划分函数 p(n) 表示将正整数 n 写成若干个正整数之和的方法数，不考虑求和顺序。

* **递推关系与估计：** p(0)=1，且 p(n)=∑k∈Z∖{0}​(−1)k+1p(n−k(3k−1)/2) 。这个递推关系由欧拉的五边形数定理给出。其渐近估计为 p(n)∼0.145/n⋅exp(2.56n​) 。手册还提供了一张小 n 值的划分函数表，例如 p(100)≈2⋅108 。

#### **6.2.2 Lucas定理**

Lucas定理提供了一种计算二项式系数在模素数下的值的方法。

* **定理内容：** 令 n,m 为非负整数，p 为素数。将 n 和 m 分别写成 p 进制表示：n=nk​pk+⋯+n1​p+n0​ 和 m=mk​pk+⋯+m1​p+m0​。则 (mn​)≡∏i=0k​(mi​ni​​)(modp) 。这在组合问题中，当二项式系数非常大但需要在模素数下计算时非常有用。

#### **6.2.3 二项式**

本节介绍了多项式系数。

* **多项式系数 (multinomial.h)：** 该模块计算多项式系数 (k1​,k2​,…,kn​k1​+⋯+kn​​)=k1​\!k2​\!…kn​\!(∑ki​)\!​ 。该函数通过迭代计算，避免了直接计算大阶乘，从而处理可能溢出的中间结果。

### **6.3 通用数**

本节涵盖了多种在组合数学、数论和分析中常见的特殊数列和函数。

#### **6.3.1 Bernoulli数**

Bernoulli数 Bk​ 在数论和分析中具有重要应用，特别是在求幂次和和欧拉-麦克劳林公式中。

* **指数生成函数 (EGF)：** Bernoulli数的EGF为 B(t)=et−1t​，这表明它们可以通过FFT进行计算 。  
* **前几项：** B\[0,…\]=\[1,−1/2,1/6,0,−1/30,0,1/42,…\] 。  
* **幂次和：** ∑i=1n​im=m+11​∑k=0m​(km+1​)Bk​⋅(n+1)m+1−k 。  
* **欧拉-麦克劳林公式：** 用于近似求和或积分，∑i=m∞​f(i)≈∫m∞​f(x)dx+2f(m)​−12f′(m)​+720f′′′(m)​+O(f(5)(m)) 。

#### **6.3.2 第一类Stirling数**

第一类Stirling数 c(n,k) 计数将 n 个元素排列成 k 个循环的方式数。

* **递推关系：** c(n,k)=c(n−1,k−1)+(n−1)c(n−1,k)，其中 c(0,0)=1 。  
* **生成函数：** ∑k=0n​c(n,k)xk=x(x+1)…(x+n−1) 。

#### **6.3.3 Eulerian数**

Eulerian数 E(n,k) 计数 n 个元素的排列 π∈Sn​ 中，恰好有 k 个元素大于其前一个元素的方式数。

* **递推关系：** E(n,k)=(n−k)E(n−1,k−1)+(k+1)E(n−1,k) 。  
* **边界条件：** E(n,0)=E(n,n−1)=1 。

#### **6.3.4 第二类Stirling数**

第二类Stirling数 S(n,k) 计数将 n 个不同元素划分成 k 个非空组的方式数。

* **递推关系：** S(n,k)=S(n−1,k−1)+kS(n−1,k) 。  
* **边界条件：** S(n,1)=S(n,n)=1 。

#### **6.3.5 Bell数**

Bell数 B(n) 计数将 n 个不同元素划分成任意数量非空组的方式数。

* **递推关系：** B(n)=∑k=0n−1​(kn−1​)B(k)。  
* **前几项：** B(0)=1,B(1)=1,B(2)=2,B(3)=5,… 。

#### **6.3.6 带标签无根树**

本节提供了带标签无根树的计数公式。

* **n 个顶点的树数量：** nn−2 (Cayley公式) 。  
* **k 棵大小为 ni​ 的现有树：** n1​n2​…nk​nk−2。  
* **具有度数 di​ 的树数量：** (d1​−1)\!…(dn​−1)\!(n−2)\!​ 。

#### **6.3.7 Catalan数**

Catalan数 Cn​ 是组合数学中一个重要的数列，出现在许多计数问题中。

* **定义与公式：** Cn​=n+11​(n2n​)=(n+1)\!n\!(2n)\!​ 。  
* **递推关系：** Cn+1​=n+22(2n+1)​Cn​ 和 Cn+1​=∑i=0n​Ci​Cn−i​ 。  
* **常见解释：** 包括 n×n 网格中的次对角线单调路径、n 对括号正确嵌套的字符串、具有 n+1 个叶子的二叉树、具有 n+1 个顶点的有序树、将 n+2 边凸多边形切割成三角形的方式数，以及没有3项递增子序列的 n 阶排列 。

这些组合数学工具为解决计数、概率和结构分析问题提供了强大的框架。

## **第七章 图论**

图论是竞技编程的核心领域之一，KTH手册提供了从基本图遍历到高级网络流和匹配算法的全面工具集。

### **7.1 基础**

本节涵盖了图论中的基本算法，用于计算最短路径和处理图的拓扑结构。

* **Bellman-Ford 算法：** 该算法用于在可能存在负边权的图中计算从源点 s 到所有其他节点的最短路径 。无法到达的节点距离设为无穷大，而通过负权环可达的节点距离设为负无穷大。其时间复杂度为 O(VE)，其中 V 是节点数，E 是边数 。  
* **Floyd-Warshall 算法：** 该算法用于计算有向图中所有节点对之间的最短路径，同样可以处理负边权 。输入是一个距离矩阵 m，其中 m\[i\]\[j\] 表示 i 到 j 的距离。输出矩阵 m\[i\]\[j\] 将被设置为最短距离，如果无路径则为无穷大，如果路径经过负权环则为负无穷大。其时间复杂度为 O(N3) 。  
* **拓扑排序 (TopoSort)：** 对于有向无环图（DAG），拓扑排序生成一个顶点的线性序列，使得所有有向边都从序列中靠前的顶点指向靠后的顶点 。如果图中存在环，则返回的列表大小将小于节点总数，因为环中的节点无法被拓扑排序。其时间复杂度为 O(∣V∣+∣E∣) 。

### **7.2 网络流**

网络流问题涉及在有向图中寻找最大流量或最小费用流量，广泛应用于资源分配、匹配和调度问题。

* **Push-Relabel 算法：** 这是一种高效的最大流算法，采用最高标签选择规则和间隙启发式 。在实践中，它通常表现出良好的性能，时间复杂度为 O(V2E​) 。  
* **最小费用最大流 (MinCostMaxFlow)：** 该算法在寻找最大流的同时，最小化总费用 。如果图中存在负费用边，需要在调用 maxflow 之前调用 setpi 函数进行势能初始化，但不支持负费用环。其时间复杂度为 O(FElogV)（其中 F 是最大流），setpi 的时间复杂度为 O(VE) 。  
* **Edmonds-Karp 算法：** 这是一种基于增广路径的流算法，其时间复杂度有保证为 O(VE2) 。  
* **最小割 (MinCut)：** 在运行最大流算法之后，从源点 s 到汇点 t 的最小割的左侧（s侧）由所有从 s 可达的顶点组成，这些顶点只能通过剩余容量为正的边遍历 。  
* **全局最小割 (GlobalMinCut)：** 该算法用于在无向图中找到一个全局最小割，通常通过邻接矩阵表示图 。其时间复杂度为 O(V3) 。  
* **Gomory-Hu 树：** 给定一个表示无向流图的边列表，该算法返回 Gomory-Hu 树的边 。任意一对顶点之间的最大流等于其在 Gomory-Hu 树路径上的最小边权。其时间复杂度为 O(V) 次流计算 。

### **7.3 匹配**

匹配问题旨在图中找到一组不共享顶点的边，以满足特定条件。

* **Hopcroft-Karp 算法：** 这是一种快速的二分图最大匹配算法 。其时间复杂度为 O(V​E) 。  
* **DFS 匹配 (DFSMatching)：** 一种简单的二分图匹配算法，时间复杂度为 O(VE) 。  
* **最小顶点覆盖 (MinimumVertexCover)：** 在二分图中，最小顶点覆盖的大小等于最大匹配的大小，其补集是最大独立集 。  
* **带权匹配 (WeightedMatching)：** 实现了匈牙利算法，用于解决带权二分图的最小费用完美匹配问题 。通过对费用取负，可以解决最大费用匹配问题。其时间复杂度为 O(N2M) 。  
* **一般图匹配 (GeneralMatching)：** 针对一般图的匹配算法，其成功概率为 N/mod，时间复杂度为 O(N3) 。

### **7.4 DFS 算法**

深度优先搜索（DFS）是图遍历的基本方法，并在此基础上衍生出多种高级图算法。

* **强连通分量 (SCC)：** 该算法用于在有向图中找到强连通分量 。如果顶点 u,v 属于同一个分量，则 u 可以从 v 到达，反之亦然。算法以逆拓扑顺序访问所有分量，并为每个节点分配一个分量索引。时间复杂度为 O(E+V) 。  
* **双连通分量 (BiconnectedComponents)：** 用于在无向图中找到所有双连通分量，并对每个分量中的边执行回调操作 。在一个双连通分量中，任意两个节点之间至少存在两条不同的路径。不属于任何双连通分量的边是桥，即不属于任何环。时间复杂度为 O(E+V) 。  
* **2-SAT：** 该算法用于求解2-SAT问题，即为布尔变量分配真值，使得形如 (a∨b)∧(¬a∨c)∧… 的布尔表达式为真 。如果问题无解，则报告不可满足。时间复杂度为 O(N+E)，其中 N 是布尔变量数，E 是子句数 。  
* **欧拉路径/回路 (EulerWalk)：** 该算法用于在无向或有向图中寻找欧拉路径或欧拉回路 。它返回一个欧拉路径/回路中的节点列表，如果不存在则返回空列表。时间复杂度为 O(V+E) 。

### **7.5 着色**

图着色问题旨在为图的元素（顶点或边）分配颜色，以满足特定约束。

* **边着色 (EdgeColoring)：** 给定一个最大度为 D 的简单无向图，该算法计算一个 (D+1)-边着色，使得没有相邻的边共享颜色 。虽然 D-边着色是NP-hard问题，但对于二分图可以通过重复匹配最大度节点来实现。其时间复杂度为 O(NM) 。

### **7.6 启发式算法**

启发式算法旨在为复杂问题提供近似或高效的解决方案，尤其是在精确解难以获得时。

* **最大团 (MaximalCliques)：** 该算法用于寻找图中的所有极大团（maximal cliques），并对每个团执行回调操作 。一个团是图中任意两点都相邻的子图；一个极大团是不能再添加任何顶点使其仍然是团的团。其时间复杂度为 O(3N/3)，但对于稀疏图会快得多 。  
* **最大独立集 (MaximumIndependentSet)：** 最大独立集问题与最大团问题密切相关：一个图的最大独立集是其补图的最大团 。对于二分图，最大独立集可以通过最小顶点覆盖来获得。

### **7.7 树**

树是图论中一种特殊且广泛应用的数据结构，本节提供了处理树的多种高级算法。

* **二分跳跃 (BinaryLifting)：** 该技术用于在树中计算2的幂次跳跃，从而支持快速的向上跳跃和最近公共祖先（LCA）查询 。它假设根节点指向自身。构建时间复杂度为 O(NlogN)，查询时间复杂度为 O(logN) 。  
* **最近公共祖先 (LCA)：** 该数据结构用于计算树中任意两个节点的最近公共祖先 。其构建时间复杂度为 O(NlogN)，查询时间复杂度为 O(Q) 。  
* **树压缩 (CompressTree)：** 给定一个有根树和节点的一个子集 S，该算法计算包含所有这些节点的最小子树，通过添加所有（最多 ∣S∣−1 对）成对的LCA并压缩边来实现 。它返回一个表示以0为根的树的列表，其中包含 (父节点, 原始索引) 对。时间复杂度为 O(∣S∣log∣S∣) 。  
* **重链剖分 (HLD)：** 该技术将一棵树分解为顶点不相交的重路径和轻边，使得从任何叶子到根的路径上最多包含 logN 条轻边 。它支持路径和子树上的加法修改和最大值查询，也可以扩展到其他可交换的线段树操作。时间复杂度为 O(log2N) 。  
* **Link-Cut Tree：** 该数据结构表示一个无根树的森林。它允许添加和删除边（只要结果仍是森林），并检查两个节点是否在同一棵树中 \[
